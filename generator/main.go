// Copyright (c) 2016 - Sarjono Mukti Aji <me@simukti.net>
// Unless otherwise noted, this source code license is MIT-License

package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	sourceUrl  = "https://raw.githubusercontent.com/FGRibreau/mailchecker/master/list.json"
	outputFile = "../domain_list.go"
)

func main() {
	u, _ := url.Parse(sourceUrl)
	tempFile := filepath.Join(os.TempDir(), filepath.Base(u.Path))
	o, oErr := os.Create(tempFile)
	if oErr != nil {
		log.Fatalln(oErr)
	}
	defer o.Close()

	r, err := http.Get(sourceUrl)
	if err != nil {
		log.Fatalln(err)
		os.Remove(tempFile)
	}

	if r.StatusCode != http.StatusOK {
		log.Fatalln("Remote file inaccessible")
		os.Remove(tempFile)
	}
	defer r.Body.Close()

	if _, dErr := io.Copy(o, r.Body); dErr != nil {
		log.Fatalln(dErr)
		os.Remove(tempFile)
	}

	reader, _ := ioutil.ReadFile(tempFile)
	lines := strings.Split(string(reader), "\n")

	for i, line := range lines {
		if strings.Contains(line, "//") {
			lines[i] = ""
		}
	}

	output := strings.Join(lines, "\n")
	sl := [][]string{}

	if err := json.Unmarshal([]byte(output), &sl); err != nil {
		log.Fatalln(err)
		os.Remove(tempFile)
	}

	dl := map[string]bool{}
	for _, list := range sl {
		for _, domain := range list {
			dl[strings.ToLower(strings.TrimSpace(domain))] = true
		}
	}

	res := []string{}
	for dm := range dl {
		res = append(res, dm)
	}
	sort.Strings(res)

	destFile, _ := filepath.Abs(outputFile)
	out, outErr := os.Create(destFile)

	if outErr != nil {
		log.Fatalln(outErr)
		os.Remove(tempFile)
	}
	defer out.Close()

	w := bufio.NewWriter(out)
	w.WriteString("// Copyright (c) 2016 - Sarjono Mukti Aji <me@simukti.net>\n")
	w.WriteString("// Unless otherwise noted, this source code license is MIT-License\n\n")
	w.WriteString("// --- THIS FILE IS AUTOGENERATED, DON'T CHANGE THIS ! ---\n")
	w.WriteString(fmt.Sprintf("// --- PARSED FROM : %s ---\n\n", sourceUrl))
	w.WriteString("package emailcheck\n\n")
	w.WriteString("var (\n")
	w.WriteString("\tdisposableDomain = map[string]bool{\n")
	for _, do := range res {
		w.WriteString(fmt.Sprintf("\t\t\"%s\":%v,\n", do, true))
	}
	w.WriteString("\t}\n")
	w.WriteString(")\n")
	w.Flush()

	// delete temporary file after all process done
	os.Remove(tempFile)
}
